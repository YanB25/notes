[toc]
##浮点相关
####IEEE764标准
$value = (-1)^s * M * 2^E$  
|位数|s |e| f|
|-|-|--|--|
|32|1 |8 |23|
|64|1 |11| 52|
1. 规格化
$M = 1+f$
$E = e-Bias$
$Bias = 2^{k - 1} - 1$
2. 非规格
e全为零
**$M = f$**
$E = e-Bias$
$Bias = 2^{k - 1} - 1$
3. 特殊值
e全为1,f全为0,表示无穷大
e全是1，f不全是0，表示NaN
e和f全为零，表示零
###浮点运算
####一位乘法
符号位和数值分开计算。
设x = 0.$x_1x_2x_3..x_n$
设y = 0.$y_1y_2y_3..y_n$
acc = 0
$y_i$ from $y_n$ to $y_1$
acc += x * $y_i$ (注意此时$y_i$是0或者1)
acc >>= 1
若acc为R0，x为R1，y为R2,则往往会将R0与R2拼接在一起，整体作右移。
运算结束后，`R0:R2`（长度为2n）则为结果

####二位乘法
NULL
####基于摩尔定律的乘法优化
并行求出乘数`32`个位乘以被乘数的值
用树状方法两两相加，层层相加
时间复杂度为`log(n)`
####除法
1. 原码一位除法（恢复余数法）
设`n`位被除数`a`，`n`位除数`t`，商`q`和余数`r`
将除数`a`拓展位2n位
将除数置于高`n`位（相当于在`2n`位寄存器中左移`n`位）
`r = a`
重复
    1. `r -= t`
        1. 若`r`小于零，恢复余数，商左移
        2. 若`r`大于零，商左移后低位置1
    1. 除数右移一位
    1. 重复(n+1)次
4. 原码一位除法（加减交替法）
####浮点数加减运算
x = 0.11011011 * $2^5$
y = (-0.10101100) * $2^7$
(假设阶码偏移量是3)
化成双符号数的补码形式（保证不发生溢出）
x = 00 :11011011 :010(阶码)
y = 11 :01010100 :100
1. 对阶
采用右移的方式对阶
x = 00 :00110110(11) :100
右移两位，舍去两位
2. 求和
sum = 11 : 10001010(11) : 100
3. 规格化处理
若sum的两个符号位符号不同，则发生了溢出（并不是真正的溢出，只是和产生了进位），右移一位（补符号位，不再发生溢出），保持“双符号”表示形式不变。（阶码+1）
若sum符号位相同，则持续左移（舍去高位，阶码-1），直到化到最简
sum = 11 : 00010101(1) : 011
4. 舍入操作
根据舍去数据的最高位（这里是舍入位只有`1`了）。0舍1入。为sum加一
sum = 11 : 00010110 : 011
5. 溢出判断
溢出只存在于阶码溢出。若阶码下溢，直接将结果置为机器`0`
若结果上溢，置溢出标志
###规格化数(补码)
1. 尾数域的最高有效位为1（正数），或最高有效位为0（负数）
形如111.101和0.0001这些都未化到最简或未将小数点平移到合适的位置
1. 课本定义（使用哪个？）:不含前导零且小数点前只有一位整数
2. 左规格化
左规格化的目的是将数字规格化
3. 右规格化
右规格化是为了防止溢出
####规格化数的作用
1. 简化了浮点数的数据交换
2. 简化了浮点算术运算
3. 提高了存储的数的精度（因为不存储前导0）
###舍入
IEEE标准在计算中，右边总是多保留两个位。首位称为保护位，第二位称为舍入位。