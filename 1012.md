[toc]
###课堂笔记
####ASCII常用记忆
1. 30H `0`
2. 41H `A`
3. 61H `a`
4. 20H `space`
####汉字编码
1. 输入编码
    1. 拼音
    2. 五笔
    3. 直接数字编码（电报码）
    4. 整字编码（汉字整字大键盘）
2. 交换码
    1. 我国统一使用`gb2312-80`作为交换码
3. 机器内码
    1. 区位码 + `a0a0H`后得到的码组。计算机中实际存储的数据
4. 字模码

####校验码
1. 检错码：仅能检验错误
2. 纠错码：能发现并纠正错误
    1. 汉明码

####补码
1. 反码加一即可
例如-0.0101
取反后1.1010
加一后1.1011
即为该数的补码

####溢出的概念与检验方法
1. 注意：溢出跟数的位数有关系。故判断溢出时，不能随便扩充位数，以免得到错误的结论
3. 检验上下溢
    1. 双符号位法（变形补码）（模4补码）
        1. 正负相加必定不溢出
        2. 将两个数的符号位**补充多一位**
        3. 上述步骤相当于把数位扩充了一倍（按照这个方式运算必定不会溢出）
        3. 若结果进行**正常补码运算**后，结果为`10`则为下溢出（由于运算时补充过一位，故高位的`1`应该舍弃）
        4. 若结果为`01`则为上溢
        5. 可用$s_1$^$s_2$判断
    2. 单符号位法
        1. 当最高有效位产生进位而符号位无进位时，产生上溢
        2. 当最高有效位无进位而符号位有进位时，产生下溢。
####运算
#####一位乘法
符号位和数值分开计算。
设x = 0.$x_1x_2x_3..x_n$
设y = 0.$y_1y_2y_3..y_n$
acc = 0
$y_i$ from $y_n$ to $y_1$
acc += x * $y_i$ (注意此时$y_i$是0或者1)
acc >>= 1
若acc为R0，x为R1，y为R2,则往往会将R0与R2拼接在一起，整体作右移。
运算结束后，`R0:R2`（长度为2n）则为结果

#####二位乘法
NULL
#####除法
1. 原码一位除法（恢复余数法）
4. 原码一位除法（加减交替法）
#####浮点数加减运算
x = 0.11011011 * $2^5$
y = (-0.10101100) * $2^7$
(假设阶码偏移量是3)
化成双符号数的补码形式（保证不发生溢出）
x = 00 :11011011 :010(阶码)
y = 11 :01010100 :100
1. 对阶
采用右移的方式对阶
x = 00 :00110110(11) :100
右移两位，舍去两位
2. 求和
sum = 11 : 10001010(11) : 100
3. 规格化处理
若sum的两个符号位符号不同，则发生了溢出（并不是真正的溢出，只是和产生了进位），右移一位（补符号位，不再发生溢出），保持“双符号”表示形式不变。（阶码+1）
若sum符号位相同，则持续左移（舍去高位，阶码-1），直到化到最简
sum = 11 : 00010101(1) : 011
4. 舍入操作
根据舍去数据的最高位（这里是舍入位只有`1`了）。0舍1入。为sum加一
sum = 11 : 00010110 : 011
5. 溢出判断
溢出只存在于阶码溢出。若阶码下溢，直接将结果置为机器`0`
若结果上溢，置溢出标志
####规格化数(补码)
1. 尾数域的最高有效位为1（正数），或最高有效位为0（负数）
形如111.101和0.0001这些都未化到最简或未将小数点平移到合适的位置
2. 左规格化
左规格化的目的是将数字规格化
3. 右规格化
右规格化是为了防止溢出
###作业
1. 设计一个四位ALU，写出一个含溢出判断，加减乘除和逻辑运算功能。**写出设计过程？？？**
    1. 一位加法器
    2. 四位加法器
    3. 溢出判断，加减乘除
    4. 逻辑函数发生器（三位或四位）(3-8译码器或者4-16译码器)
2. 浮点运算
